<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Lecture Notes]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>Lecture Notes</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Wed, 26 Nov 2025 02:10:27 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Wed, 26 Nov 2025 02:10:26 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[06. Topic Models]]></title><description><![CDATA[
Topic models address information overload by helping to Automatically process data. Traditional NLP solutions include Summarization, Information extraction, and Question answering.
Goals: Topic models aim to Cluster/Organize data, Discover hidden themes, and Annotate documents with themes.
Topic Definition: A topic is characterized conceptually by frequent words, and formally as a Distribution over words.
Task: This is an Unsupervised text clustering task. Input: Corpus and the specified Number of Topics ().
Output: The learned Topics (Distribution over words) and Topics per document. The dataset is defined as a Collection of documents.
Document Representation: Individual documents are typically represented using a Bag-of-word representation (a -dimensional vector, where is the vocabulary size).
Collection Representation: A collection of documents is represented as a -dim matrix.
Matrix Values: Matrix values can represent Counts, Indicator function, or TF-IDF.
LSA is a non-probabilistic approach designed to Model which words typically co-occur using matrix representation.
Method: The core idea is to Perform matrix factorization, specifically using SVD (Singular Value Decomposition) to yield Latent Semantic Analysis. represents the Number of topics.
Probabilistic models assume that the observed data is generated by a generative probabilistic process that includes hidden variables. The hidden variable in topic modeling is the Thematic structure. The main task is to Infer hidden structure and Generalize to new data.LDA is the primary probabilistic model used (Blei, 2003).
Name Breakdown: Latent: Topic is unknown / Latent in the text.
Dirichlet: Refers to the Distribution of distributions. Documents are Distributions of topics, and Topics are Distributions of words.
Allocation: Allocate topics to the words. Process/Intuition: Documents exhibit multiple topics. Topics are Distributions over words; Documents are a Mixture of topics; and words are Drawn from one of the topics. The major challenge is that Only documents are observed, while topics are hidden variables.
Graphical Model: This model encodes assumptions and dependencies. Nodes represent random variables, and Shaded nodes () represent the Observed word. Plates indicate replications (e.g., for documents, for words within documents, for topics).
<img alt="Pasted image 20251126030848.png" src="attachments/pasted-image-20251126030848.png" target="_self">
The goal of inference is to compute the posterior distribution conditioned on the documents: .
Variables to Infer: Per-word topic assignment (), Per-document topic proportions (), and Per-corpus topic distribution ().
Challenge: The posterior distribution Cannot be computed exactly due to the intractable marginal likelihood. Even assuming the global variable (Topic, ) is fixed, local inference (for ) remains intractable.
Solution: Approximate methods, such as Gibbs sampling, are necessary.
Gibbs sampling is an iterative Markov Chain Monte Carlo method used for approximation.
Procedure: Start with random assignment of all random variables (topic-word allocation, topic distribution, document distribution).
For a given word, Keep everything except that word fixed.
Assign a topic to this word based on current distribution.
Repeat for several iterations. Sampling Formula: The probability of assigning topic to word is proportional to the product of two components: Document Likelihood: How much document likes topic (). This depends on (Number of times document uses topic ) and (Dirichlet parameter for document to topic distribution).
Topic Likelihood: How much topic likes word (). This depends on (Number of times topic uses word type) and (Dirichlet parameter for topic to word distribution). Evaluating topic models (Unsupervised learning) differs from supervised learning.
Measure 1: Held-out Log Likelihood: A good model should assign a High probability for real data (held-out data).
Measure 2: Word Intrusion: This measure tests topic coherence. A user is presented with the most probable words for a topic, plus a high probability word from another topic (the intruder). The user is asked to find the word that does not belong, and the metric is the Percentage of users who selected the intruder.
Note: Evaluation metrics do not always agree; it is necessary to Measure what you need.
]]></description><link>natural-language-processing/06.-topic-models.html</link><guid isPermaLink="false">Natural Language Processing/06. Topic Models.md</guid><pubDate>Wed, 26 Nov 2025 02:10:16 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[05. Semantics]]></title><description><![CDATA[We learned from the part 1 that there are multiple NLP tasks. Most of them require the machine to understand the meaning of the sentence and generate corresponding answers. We learned Word2Vec to generate words from part 3. So, today we are going to dive into the study of meaning.Semantics is defined as the Study of meaning. It is distinct from Morphology (how words are built) and Syntax (how words form larger units like phrases/sentences).The field is generally divided into two core branches:
Lexical Semantics: The study of word meaning.
Compositional Semantics: The study of the meaning of sentences.
Lexical semantics (5.1) studies the meaning of words.
Lexeme: The abstract representation of a word (e.g., MOUSE, mice).
Sense: A discrete representation of one aspect of the meaning. The meaning of a word can vary based on the given context (e.g., MOUSE as an animal versus a hand-operated device). Synonyms &amp; Antonyms: Synonyms: Two words with (nearly) identical senses (e.g., couch/sofa). The Principle of contrast suggests that different linguistic forms are always associated with a difference in meaning (e.g., "H2O" is more scientific than "water").
Antonyms: Words with opposing meaning, mostly adjectives (e.g., Long/short, Rise/fall). Taxonomic Relations: Hyponym: A word that is more specific (e.g., Car is a hyponym of vehicle).
Hypernym/Superordinate: A word that is less specific (e.g., Vehicle is a hypernym of car).
<img alt="Pasted image 20251126025836.png" src="attachments/pasted-image-20251126025836.png" target="_self">
Meronym: Represents part-whole relations (e.g., Wheel is a meronym of car).
The Basic Level: Items are "human-sized," have distinctive actions, are learned earliest in childhood, and their names are shortest and most frequent (e.g., "chair" vs. its hypernym "furniture"). Similarity &amp; Relatedness: Word similarity refers to words with different but similar meanings (e.g., Dog and cat). Word embeddings can represent these relationships (e.g., Male-Female, Country-Capital).
Word relatedness refers to words belonging to the same semantic field (e.g., Waiter, Menu, Chef belong to the "restaurants" field). Homonymy: Words that share a form but have unrelated, distinct meanings (e.g., bank1: financial institution; bank2: sloping land). Homographs: Same spelling, different meanings (e.g., bank/bank).
Homophones: Same pronunciation, different meanings (e.g., write/right). Affective meaning involves aspects of a word related to emotion.
Valence: Pleasantness of the stimulus (e.g., Happy/satisfied vs. unhappy/annoyed).
Arousal: Intensity of emotion (e.g., Excited vs. calm).
Dominance: Degree of control (e.g., Controlling vs. influenced). Description: A hierarchically organized lexical database that acts as an on-line thesaurus and dictionary.
Definition of Sense: Defined by a Synset (synonym set), which is a set of near-synonyms that instantiates a sense or concept, with an accompanying gloss.<br>
<img alt="Pasted image 20251126025850.png" src="attachments/pasted-image-20251126025850.png" target="_self">
Structure: WordNet can be viewed as a graph where nodes are synsets and edges represent various relationships, such as "is-a" (hypernym/hyponym).
Supersenses: Top-level hypernyms in the hierarchy (e.g., Noun supersenses include GROUP, PERSON, ARTIFACT).
Challenges: Resolving Ambiguity (one form, multiple meanings split form) and Variability (multiple forms, one meaning merge forms).
Compositional semantics (5.2) studies the meaning of sentences. The central challenge is the infinite number of sentences.
Frege's Principle of compositionality: The meaning of an expression depends on the meaning of its parts and how they are put together.
This involves structuring meaning using symbols, bridging the gap between language and common-sense knowledge.
Vocabulary: Includes Non-logical (open-ended terms linked to a world model) and Logical (closed set of symbols, operators, quantifiers) elements.
Examples of Representations: First-order logic, Abstract Meaning Representation (AMR), and Frame-based/slot-filling representation.
Requirements: Verifiability: Ability to compare the represented state to the state of the world (e.g., checking Serves(Maharani, VegetarianFood) against a knowledge base).
Unambiguous representations: The representation itself must be clear, even if the natural language sentence is vague.
Canonical Form: Distinct inputs with the same meaning must yield the same representation.
Inference and Variables: Variables are needed to make general statements, and the system must use world knowledge to draw conclusions.
Expressiveness: Must handle a wide range of expressions. This is a flexible and well-understood meaning representation. It uses Terms (objects), Functions (e.g., LocationOf(Frasca)), and Variables to make general statements.Shallow semantics aims to represent the commonality of an event despite its linguistic variability (e.g., different ways to describe a stock purchase).
Thematic Roles: Identify common roles like AGENT (often the subject) and THEME.
Challenges: Fragmentations (e.g., multiple types of INSTRUMENTS) and difficulty in defining roles (e.g., whether an Agent must be animate).
Alternatives: Use broader roles like PROTO-AGENT (Agent-like properties) and PROTO-PATIENT (Patient-like properties). PropBank (Proposition Bank) (5.2.4): A dataset based on Penn TreeBank annotation, focusing primarily on verbs.
Uses numbered roles (Arg0, Arg1, etc.) specific to each verb sense. Arg0 typically represents the PROTO-AGENT, and Arg1 the PROTO-PATIENT.
ArgMs represent modifications like time (TMP), location (LOC), or reason (PRP/CAU). FrameNet (5.2.5): Motivated by the need for inference about situations described by different verbs (e.g., increased vs. rose).
Defines Frames as background knowledge structures containing common-sense information about a situation (e.g., Change_position_on_a_scale).
Uses Core roles that are specific to the frame, and Non-core roles (general properties) comparable to PropBank's Arg_M. Reasoning (5.3) takes Facts and Logic as input to generate an Answer.
Deductive Reasoning: Moves from premise(s) to a Firm conclusion using logic (e.g., All whales are mammals All whales have kidneys). (general -&gt; special)
Inductive Reasoning: Moves from observation to a Likely conclusion (e.g., winged creatures are usually birds this winged creature is likely a bird). (special -&gt; general)
Abductive Reasoning: Moves from observation to a Likely explanation.
Formal Reasoning: Follows formal rules/logic and is based on axiomatic knowledge.
Informal Reasoning: Uses intuition, experience, and common sense. Goal: An applied semantic inference task aimed at identifying the logical relationship between a pair of text sequences (a Premise and a Hypothesis).
Also called: Textual Entailment.
Labels: Entailment: Hypothesis is true.
Contradiction: Hypothesis is false.
Neutral (Undetermined): Hypothesis is undetermined. ]]></description><link>natural-language-processing/05.-semantics.html</link><guid isPermaLink="false">Natural Language Processing/05. Semantics.md</guid><pubDate>Wed, 26 Nov 2025 02:03:40 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[04. Sentence Structure]]></title><description><![CDATA[Part-of-Speech (POS): POS tags classify words based on their grammatical relationship and functional category (e.g., noun, verb) in context. This differs from word sense (meaning).
Classification: Words belong to Open classes (lexical words) (Nouns, Verbs, Adjectives, etc.) or Closed classes (functional) (Determiners, Pronouns, Conjunctions).
Universal Tag Set: Smaller, coarser sets (like the 12-tag Universal Tag Set) are used for cross-lingual purposes.
Challenge (Ambiguity): Many word instances are ambiguous, meaning the same word type can have multiple POS tags (e.g., "back" can be JJ, NN, RB, or VB). POS tagging is the process of determining the correct tag for a word given its context.
Syntax studies how words organize into hierarchical units called constituents (phrases). Only entire phrases, such as a Prepositional Phrase (PP), can be moved within a sentence. Context Free Grammar: Introduced by Chomsky, CFG is a formal system used to generate sentences and assign parse trees. Non-terminals () are phrase variables (NP, VP), and Terminals () are the actual words. Phrase Structure Grammar: This applies CFG rules to define natural language structures (e.g., Declarative sentences are NP VP). Subcategorization: Verbs enforce constraints on the required accompanying phrases; e.g., Transitive verbs require a direct object, while Intransitive verbs do not.
Ambiguity: A sentence can have multiple correct parse trees (Structural Ambiguity). This includes Attachment ambiguity and Coordination ambiguity. Lexicalized Grammars (e.g., Combinatory Categorial Grammar): These models use a lexicon to encode complex grammatical dependencies like Agreement, Subcategorization, and Long-distance dependencies. Words are assigned detailed categories (e.g., the verb "Cancel" has the category ). Forward rule application ()
Backward rule application ()
<img alt="Pasted image 20251126025040.png" src="attachments/pasted-image-20251126025040.png" target="_self"> Dependency Grammar: This approach describes structure using directed binary relations (typed relations) between a head and its dependent. Graph : Vertices correspond to words
: Arcs corresponding to relations Restrictions: Connected
Designated root node
<br>Acyclic (connected acyclic graph is a tree) or planar <img alt="Pasted image 20251126025053.png" src="attachments/pasted-image-20251126025053.png" target="_self"> Language Models automatically learn sentence structure by assigning a Probability to a sentence.Simple counting fails due to sparse data; many valid but unseen sentences are assigned a probability of zero.Solution: Chain Rule.E.g.,Estimating the probability of a word from its full history is intractable.Solution: Markov Assumption.
The probability of a word depends only on the previous words.N-gram Models: Unigram, Bigram, Trigram, etc. Though insufficient for capturing long-distance dependencies, they are practical.<br><img alt="Pasted image 20251126025309.png" src="attachments/pasted-image-20251126025309.png" target="_self">MLE estimates N-gram probabilities by maximizing the likelihood of training data.<br><img alt="Pasted image 20251126025315.png" src="attachments/pasted-image-20251126025315.png" target="_self">A key challenge persists: if an N-gram is an unseen event (count = 0), its probability is 0, making the entire sentence probability 0.If you'd like, I can also format these into a printable PDF, add color themes, or convert into study flashcards.]]></description><link>natural-language-processing/04.-sentence-structure.html</link><guid isPermaLink="false">Natural Language Processing/04. Sentence Structure.md</guid><pubDate>Wed, 26 Nov 2025 01:57:31 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[03. Neural Word Representation]]></title><description><![CDATA[NLP has undergone a major transformation over the past few decades, shifting from traditional statistical methods to modern neural network-based approaches.Early NLP systems relied heavily on statistical language models (SLMs). These models estimate the probability of a word sequence based on observed frequencies in large text corpora. N-gram models is one of the most common approaches, which predict the next word given the previous n−1 words. For example, a trigram model predicts the next word based on the previous two words.However, SLMs have limitations about data sparsity, context window, and feature engineering (SLMs often required manual preprocessing and feature extraction).In the part, we will focus on neural network based methods.Word Embedding is one of Dense Embeddings. Dense vector has the following advantages: Short vectors may be easier to use as features in machine learning (less weights to tune) Dense vectors may generalize better than storing explicit counts They may do better at capturing synonymy: car and automobile are synonyms; but are distinct dimensions
a word with car as a neighbor and a word with automobile as a neighbor should be similar, but aren’t In practice, they appear to work better So can we convert one-hot (Sparse) to Dense Embeddings? Assume there is a matrix W. We can multiply our one-hot with W. This gives us the “embedding” for a word. W is what we need to learn (in the context of machine learning).
Please read Q&amp;A for more details. Word2Vec CBOW Skip-gram Negative sampling Fasttext character representation Glove Q: What is the relationship between the corpus-based approach and feature engineering? A: In traditional Corpus-based Approaches to NLP, feature extraction is an explicit process. This feature extraction defines the features used by the statistical model, such as the word ID, case, and POS tags (e.g., Word: 546; Case: Upper-case; POS: NN). In Deep Learning Approaches, the input text still undergoes feature extraction, but the output is a dense binary vector (e.g., 10010010010101). Therefore, feature engineering is the traditional method of explicit feature extraction from the corpus, which has been largely replaced by automatic feature learning in deep learning.Q: What is an important property of word embeddings? A: An important property of word embeddings is that semantic similar words should have similar representation. This concept is tied to J.R. Firth’s 1953 dictum: “You shall know a word by the company it keeps!”.Q: What determines the size of one-hot embeddings? A: The size, or dimension, of a one-hot encoding vector is determined by the vocabulary size.Q: What is an advantage of dense embeddings? A: Dense vectors have several advantages: they are short vectors, may generalize better, and appear to work better in practice, especially at capturing synonymy.Q: What is a problem with n-gram models? A: A major problem with statistical N-gram models is that most longer word sequences have not been seen in the corpus. This requires a non-satisfactory solution like back-off to a shorter sequence. N-gram models also operate in Discrete Space.Q: Why do we call the Feed Forward Neural Network here self-supervised? A: The Feed Forward Neural Network language model is considered self-supervised because training needs only unlabelled data (pure text). The model is trained to predict the next word given previous words. The meaning of the word is important for estimating the next word, and this meaning needs to be encoded in the embedding.Q: What is the advantage of a continuous space? A: The advantage of mapping words to a continuous word representation is generalization to similar n-grams. Unlike discrete space, which only allows for exact matching, continuous space enables the model to automatically learn optimal features and find the nearest neighbor, capturing syntactic similarities and semantic similarities.Q: Is the position of the input words important? A: For the Continuous Bag of Words Model (CBOW), the position of the input words is ignored. The model sums the surrounding words to predict the center word.Q: How many embeddings do we get for each word? A: For Word2Vec models (CBOW and Skip-gram), typically there is one embedding for each word.
More details: <a data-tooltip-position="top" aria-label="https://lilianweng.github.io/posts/2017-10-15-word-embedding/" rel="noopener nofollow" class="external-link is-unresolved" href="https://lilianweng.github.io/posts/2017-10-15-word-embedding/" target="_self">Learning Word Embedding</a> <br><a data-tooltip-position="top" aria-label="https://medium.com/@fraidoonomarzai99/word2vec-cbow-skip-gram-in-depth-88d9cc340a50" rel="noopener nofollow" class="external-link is-unresolved" href="https://medium.com/@fraidoonomarzai99/word2vec-cbow-skip-gram-in-depth-88d9cc340a50" target="_self">Word2Vec (CBOW, Skip-gram) In Depth</a> Q: What is the CBOW score function based on? A: The CBOW score function is based on the dot product to measure similarity.Q: What is the difference between CBOW and Skip-gram? A: CBOW and Skip-gram have opposite objectives:
CBOW predicts the word based on surrounding words.
Skip-gram predicts the surrounding words given the current word.
Q: What is maximized with the Skip-gram objective? A: The Skip-gram objective is to maximize the probability of any context word given the current word. This objective uses a negative log loss.Q: Why is negative sampling necessary? A: Negative sampling is necessary because the standard Skip-gram objective requires normalization over the entire vocabulary, which is computationally demanding. Negative sampling resolves this by generating samples and summing over those samples instead of the entire vocabulary.Q: Why do we use sigmoid instead of softmax in the objective function? A: We use the Sigmoid function () because negative sampling converts the problem from a multiclass classifier to a binary classifier.Q: Where do we get negative examples from? A: Negative examples are sampled from the lexicon. The negative set typically contains 2 to 20 words sampled from some distribution, such as uniform, unigram, or a smoothed unigram. The smoothed unigram distribution is created by raising the probabilities to the power of and then renormalizing.Q: For a corpus with fixed size, are there more unique 6-grams or 3-grams? A: Based on the problem of N-gram models—that most longer word sequences have not been seen—it can be inferred that there would be more unique 6-grams than 3-grams, as longer sequences lead to higher sparsity.Q: How are context and target words represented with FastText? A: FastText uses character N-grams:A: FastText uses character N-grams:
The word embedding for the target word is the sum of character 3-grams to 6-grams and the whole word itself.
The word embedding for the context word is taken from the embedding table without adding character n-grams.
Q: What is the difference between Word2Vec and FastText? A: FastText is an extension of Word2Vec that addresses challenges found in Word2Vec. FastText uses subword representation (character n-grams) to solve issues in morphologically rich languages and to create representations for words that have not been seen previously.Q: What is a key difference between Word2Vec and GloVe? A: The key difference lies in the perspective used for training: Word2Vec uses a Local view (predicting words within the context), while GloVe uses a Global view. GloVe leverages Word co-occurrence matrices and is motivated by the ratio of co-occurrence probabilities.Q: In which situations does GloVe likely produce unreliable word embeddings?
Rare words – too few co-occurrences to learn meaningful vectors.
Small corpus – global statistics are sparse and noisy.
Domain mismatch – training domain differs from the target domain.
Polysemous words – one vector cannot represent multiple senses.
No subword modeling – fails on morphology and misspellings.
Out-of-vocabulary words – no embeddings for unseen words.
Biased training data – co-occurrence statistics reflect and amplify bias.
]]></description><link>natural-language-processing/03.-neural-word-representation.html</link><guid isPermaLink="false">Natural Language Processing/03. Neural Word Representation.md</guid><pubDate>Wed, 26 Nov 2025 01:44:46 GMT</pubDate></item><item><title><![CDATA[02. Words]]></title><description><![CDATA[Example (Chinese): 我看书 — “I read/look at a book.”. Morphemes:
我 = I
看 = read/look
书 = book
Key idea: Minimal or no inflection; morphemes usually stand alone.Example (Turkish): ev-ler-in-de — “in your houses”. Morphemes:
ev = house
-ler = plural
-in = your
-de = in
Key idea: Morphemes have clear boundaries and single meanings, attached in sequence.Example (Spanish): habl-o — “I speak”. Morphemes:
habl- = speak
-o = 1st person + singular + present
Key idea: A single morpheme typically encodes multiple grammatical features.Example (Inuktitut): tusaatsiarunnanngittualuujunga — “I really can’t hear well”. Simplified morphemes:
tusaa- = hear
-tsiaq- = well
-junnaq- = be able
-nngit- = not
-tualuu- = very
-junga = I
Key idea: Many morphemes combine to express what would be a whole sentence.Example (Arabic): kitaab — “book”. Morphemes:
k-t-b = root “write”
i__a__ = vocalic pattern forming a noun
Key idea: Words are formed by inserting vocalic patterns into consonantal roots.
Lexeme, e.g., SEE
Word-form, e.g., saw, seeing, saws
Paradigm, e.g., I, my, mine, me
Word family, e.g., act, action, actor, activate, active, activist Lexical/Content
Functional
Root Suffix
Prefix
Infix
Circumfix Changes the grammatical form of a word without creating a new lexeme.
Does not change core meaning or word class.
Typical categories: tense, number, case, agreement.
Examples:
walk → walks (3sg)
cat → cats (plural)
see → saw (past) Forms a new word (new lexeme) by adding derivational affixes.
Often changes meaning and sometimes word class.
Examples:
happy → unhappy
nation → national
modern → modernize
read → reader Combines two or more roots/words to form a new lexeme.
The components remain recognizable.
Examples:
black + board → blackboard
sun + light → sunlight
ice + cream → ice-cream
Here’s a concise English note summarizing the morphological processes you listed, with clear examples:
Maps a word form to its lemma (dictionary/base form).
Ignores context.
Example:
saw → see Lemma and Lexeme are different. Lexeme is an abstract concept, while lemma is a concrete concept. Breaks a word into (lemma + grammatical tag).
Does not consider context, so may produce multiple analyses.
Example:
saw → {(see, verb.past), (saw, noun.sg)} Uses context to select the correct analysis.
Example:
Sentence: Peter saw her
saw → {(see, verb.past)} Splits a word into its smallest meaningful units (morphemes).
Example:
de-nation-al-iz-ation → de + nation + al + iz + ation Produces a word form from a lemma + features.
Essentially the reverse of lemmatization.
Example:
(see, verb.past) → saw
Both Feature Engineering (FE) and Representation Learning (RL) are methodologies designed to solve the critical challenge in machine learning models: how to map text into a fixed vector representation, or .However, they differ fundamentally in their approach, timeframe, and resulting data structure.Feature Engineering (FE) represents the dominant methods used over the last 25 years. This approach relies on manually defined templates to describe the important information of the text. FE is often decried as “costly, hand-crafted, expensive, domain-specific,” among other criticisms. While simple features typically give the bulk of the performance and can yield high accuracies, the feature set is still difficult to maintain.Representation Learning (RL) describes the methods developed over the last 10 years. The defining characteristic of RL is that the features are automatically learned. The result of this process is an approximation, meaning some information are lost, and the representation is typically task dependent.The methodologies lead to stark differences in the resulting vector format:
FE commonly uses representations like the Bag of Words (BoW). This approach results in a Sparse matrix, where most entries are zero. BoW uses one feature per word, which can be a Binary feature (0 or 1) or a Count feature. Feature Importance and TF-IDF can help solve problems respectively about word importance and high-frequently used no-meaning words.
RL generates a Neural representation, which is characterized as Dense. Negation: It's not a great monster movie.
Different sense: There's a great deal of corny dialogue and preposterous moments.
Multiple sentiments: A great ensemble cast can't lift this heartfelt enterprise out of the familiar.
Number of features: Too few. Hard to distinguish different inputs
Too many. Overfitting Representation Learning evolved to better handle critical challenges inherent in text data that constrained Feature Engineering:
Word Order and Length: FE methods like BoW ignore word position when dealing with variable length input. Although FE can use Higher-Order Binary Feature Templates (like bigrams or trigrams) to consider word order and maintain a fixed size vector representation, this introduces the challenge of an extremely large number of features. Conversely, RL must address the fact that word order is important and must handle variable length input.
Open Vocabulary: For FE, open vocabulary is a challenge that requires the use of a fixed vocab. RL also faces the open vocabulary challenge, but aims to solve it by being able to understand unknown words, such as the complex term Hippopotomonstrosesquipedaliophobia.
Granularity: RL’s approach to solving vocabulary challenges involves identifying the best granularity—choosing among words, subwords, or characters. RL acknowledges that while using characters provides much training data and allows understanding of unknown words, it leads to long sequences for text, which is not efficient. Therefore, RL uses machine learning based subword segmentation to learn efficient representation. Techniques like Byte-Pair Encoding (BPE), which starts with an Initial vocabulary of characters to ensure every words can be represented, are employed to strike this balance.
]]></description><link>natural-language-processing/02.-words.html</link><guid isPermaLink="false">Natural Language Processing/02. Words.md</guid><pubDate>Wed, 26 Nov 2025 01:29:45 GMT</pubDate></item><item><title><![CDATA[01. Introduction]]></title><description><![CDATA[NLP: Algorithms to process, analyze and understand texts in natural language
Understanding structure
Understanding meaning Ambiguity, e.g., bank
Compositionality, e.g., green thumb
Co-reference, e.g., if the baby does not like the milk, boil it
Living language, e.g., Eyjafjallajökull
Rare events
<img alt="Pasted image 20251126022044.png" src="attachments/pasted-image-20251126022044.png" target="_self">
Corpus = large collection of annotated texts (or speech files)
Linguistics
Machine learning
NLP tasks: Information Extraction + Retrieval
Summarization
Machine translation
Question Answering
Personal assistant NLP techniques (focus on deep learning-based): Data types Texts, e.g., Brown Corpus, Penn Treebank
Dictionaries/Ontologies, e.g., WordNet, GermaNet, EuroWordNet Data grows English Text Corpora (News)
Computer MT or ASR systems train on &gt;&gt; 1GWords. News Shuffle, GigaWord, Europarl, VideoLectures, …
Human speaks 0.5 GigaWords in a Lifetime! Model types Classification, e.g., word sense disambiguation
Sequence Classification, e.g., sentiment analysis
Sequence labeling, e.g., named entity recognition
Sequence to Sequence model, e.g., summerization
Structure prediction, e.g., parsing Evaluation: Human evaluation
Automatic evaluation ]]></description><link>natural-language-processing/01.-introduction.html</link><guid isPermaLink="false">Natural Language Processing/01. Introduction.md</guid><pubDate>Wed, 26 Nov 2025 01:20:46 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="."&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Home]]></title><description><![CDATA[This is where I take notes.]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Wed, 26 Nov 2025 01:18:56 GMT</pubDate></item></channel></rss>